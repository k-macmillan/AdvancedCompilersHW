% Assignment 1
\documentclass{article}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% PACKAGES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{graphicx}                   % PNGs
\usepackage{hyperref}                   % Hyperlinks
\usepackage{mathtools}
\hypersetup{
    colorlinks,
    linkcolor=black
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagenumbering{gobble}

\title{\textbf{Assignment \#1}}
\author{MacMillan, Kyle}
\date{October 10, 2018}


\begin{document}

\maketitle
\addcontentsline{toc}{section}{Title}

\newpage
\pagenumbering{roman}   % Set TOC page numbering to lowercase roman numerals
\tableofcontents
\addcontentsline{toc}{section}{Table of Contents}

% \newpage
% \listoffigures
% \addcontentsline{toc}{section}{List of Figures}

% \listofalgorithms
% \addcontentsline{toc}{section}{List of Algorithms}

\newpage
\pagenumbering{arabic}  % Set content page numbering to arabic numerals
% Setup Hyperlinks for the rest of the document
\hypersetup{
    citecolor=blue,
    filecolor=black,
    linkcolor=blue,
    urlcolor=blue
}

\setcounter{page}{1}
\section{Briefly explain the difference between}
\subsection{A compiler and an interpreter}
Compilers are different from interpreters or they would not be separate things. In general terms a compiler takes something and turns it into something else. An interpreter does the same thing but not as efficiently. The compiler we use to compile C++ will read through our code and reduce it to assembly instructions for the machine we are on. While doing this it will evaluate some parts of the code and place things in an ``optimal'' ordering. An interpreter does not look at the code until execution, meaning it has no room to perform optimizations. Another difference is that interpreters are able to take code on the fly, whereas a compiled language must have everything at compile time. 

\subsection{A statically typed language and a dynamically typed language}
Statically typed languages strictly enforce \textit{type}, whereas dynamically typed languages determine which \textit{type} to use. There are two primary benefits to statically typed languages:\\
\begin{itemize}
    \item type-safe -- You must declare the type and it will be enforced
    \item speed -- Knowing the type ahead of time means it doesn't have to figure it out on the fly
\end{itemize}

A dynamically typed language is able to determine the type on the fly which reduces development time but can also be confusing. In Python, for example, a function with a variable named ``flow''. A user may not initially know if flow is a string such as \textit{`fast', `normal'} or \textit{`slow'}, or a float such as a flow rate. This confusion can make maintenance more difficult. It can also hamper someone trying to learn the codebase. There are pros and cons of both that need to be taken into consideration when choosing a language.

\subsection{A just-in-time compiler and an interpreter}
A just-in-time (JIT) compiler compiles as you send it commands, meaning at runtime. A JIT, such as what Java uses, will take the code and compile it to bytecode. An interpreter executes instructions. A JIT will have marginally better performance compared to an interpreter.

\subsection{Top-down parsing and bottom-up parsing}
Top-down (TD) and bottom-up (BU) parsing refers to the methods of walking a parse tree. As can be assumed, they each begin at their respective ``ends'' of a tree. TD parsers can be attacked with a \textit{LL(k)} method where \textit{LL} means it descends the left nodes and has a look-ahead of \textit{k}. This naive method is 

\section{Let L be the language \{abxba \mid{} x is any string of a's, b's, and c's not containing the substring ba\}}

\section{Let L be the set of all strings of a's and b's with the same number of a's as b's}

\end{document}
